{{ reserveImport "bytes" }}
{{ reserveImport "context" }}
{{ reserveImport "encoding/json" }}
{{ reserveImport "fmt" }}
{{ reserveImport "io" }}
{{ reserveImport "io/ioutil" }}
{{ reserveImport "net/http" }}
{{ reserveImport "net/url" }}
{{ reserveImport "path" }}
{{ reserveImport "time" }}

{{ reserveImport "golang.org/x/xerrors" }}

{{ reserveImport "github.com/Yamashou/gqlgenc/graphqljson" }}
{{ reserveImport "github.com/Yamashou/gqlgenc/client" }}

type GqlClient struct {
	httpClient *client.HTTPClient
	wsClient   *client.WSClient
}

func NewHTTPClient(cli *http.Client, baseURL string, options ...client.HTTPRequestOption) *client.HTTPClient {
	return client.NewClient(cli, baseURL, options...)
}

func NewWSClient(wsURL string, opts ...client.WSClientOptionsFunc) (*client.WSClient, error) {
	return client.NewWsClient(wsURL, opts...)
}

func NewClient(httpClient *client.HTTPClient, wsClient *client.WSClient) *GqlClient {
	return &GqlClient{httpClient: httpClient, wsClient: wsClient}
}

type {{ .Query.Name | go }} {{ .Query.Type | ref }}

type {{ .Mutation.Name | go }} {{ .Mutation.Type | ref }}

type {{ .Subscription.Name | go }} {{ .Subscription.Type | ref }}

{{- range $name, $element := .Fragment }}
	type  {{ .Name | go  }} {{ .Type | ref }}
{{- end }}

{{- range $name, $element := .OperationResponse }}
    type  {{ .Name | go  }} {{ .Type | ref }}
{{- end }}

{{- range $model := .Operation }}
{{ $operationVariableName := ( print ($model.Name | go) ($model.OperationType | go) )}}
const {{ $operationVariableName }} = `{{ $model.Operation }}`

{{ if eq $model.OperationType "subscription" }}

func (c *GqlClient) {{ $model.Name|go }} (ctx context.Context{{- range $arg := .Args }}, {{ $arg.Variable | goPrivate }} {{ $arg.Type | ref }} {{- end }}, operationCtx map[string]interface{}) (chan *{{ $model.Name|go }} , chan error) {
	vars := map[string]interface{}{
	{{- range $args := .VariableDefinitions}}
		"{{ $args.Variable }}": {{ $args.Variable | goPrivate }},
	{{- end }}
	}

	resChan := make(chan *{{ $model.Name|go }} )
	errChan := make(chan error)

	dataChan, err := c.wsClient.Subscribe(ctx, {{ $operationVariableName }}, vars, operationCtx)
	if err != nil {
		errChan <- err
	}

	go func() {
		for d := range dataChan {
			data := &{{ $model.Name|go }} {}
			if err := c.wsClient.ParseSubscriptionData(d, data); err != nil {
				errChan <- err
			} else {
				resChan <- data
			}
		}

		// data channel is closed
		close(resChan)
		close(errChan)
	}()
	return resChan, errChan
}
{{ else }}

func (c *GqlClient) {{ $model.Name|go }} (ctx context.Context{{- range $arg := .Args }}, {{ $arg.Variable | goPrivate }} {{ $arg.Type | ref }} {{- end }}, httpRequestOptions ...client.HTTPRequestOption) (*{{ $model.ResponseStructName | go }}, error) {
	vars := map[string]interface{}{
	{{- range $args := .VariableDefinitions}}
		"{{ $args.Variable }}": {{ $args.Variable | goPrivate }},
	{{- end }}
	}

    var res {{ $model.ResponseStructName | go }}
    if err := c.httpClient.Post(ctx, {{ $operationVariableName }}, &res, vars, httpRequestOptions...); err != nil {
        return nil, err
    }

    return &res, nil
}
{{- end }}
{{- end }}
